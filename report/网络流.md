<center><font size="6"> 网络流、费用流 题解</font></center>
<h3 id="A">ACM Computer Factory(POJ-3436)</h3>
#### 题意

工厂组装电脑，每台电脑分配P个部分，一共有N台机器，这N台机器都有一个输入端和输出端，输入端表示需要的零件，输出端表示生产的产品

#### 思路

细节多：

- 首先一台计算机从零（开始）各种部件都没有，对应的输入端全0，与源点相连
- 组装完成的计算机（结束）各种部件都应该齐全，对应的输出端全1，与汇点相连
- 剩下根据对应关系建边，同时注意开始和结束状态不用和其他状态建边

如何输出边？

将原图备份，如果跑完网络流之后边的流量小于之前，这条边就是网络流经过的边

```cpp
#include <iostream>
#include  <vector>
#include <cstring>
#include <queue>
#include <set>
const int maxn = 50 + 5;
const int inf = 0x3f3f3f3f;
using namespace std;
int g[maxn][maxn], pre[maxn], vis[maxn];
int in[maxn][12], out[maxn][12], val[maxn];
int backup[maxn][maxn];
int n, m;
int used[maxn];
bool bfs(int s, int e) {
	memset(vis, 0, sizeof(vis));
	memset(pre, -1, sizeof(pre));
	vis[s] = 1;
	queue<int> que;
	que.push(s);
	while (!que.empty()) {
		int f = que.front();
		que.pop();
		for (int i = 0; i <= e; ++i) {
			if (g[f][i] && !vis[i]) {
				vis[i] = 1;
				pre[i] = f;
				que.push(i);
				if (i == e) return 1;
			}
		}
	}
	return 0;
}
int ek(int s, int e) {
	int ans = 0;
	while (bfs(s, e)) {
		int MIN = inf;
		for (int i = e; pre[i] != -1; i = pre[i]) {
			MIN = min(MIN, g[pre[i]][i]);
		}
		for (int i = e; pre[i] != -1; i = pre[i]) {
			g[pre[i]][i] -= MIN;
			g[i][pre[i]] += MIN;
		}
		ans += MIN;
	}
	return ans;
}
int check_in(int x) {
	for (int i = 0; i < n; ++i) {
		if (in[x][i] == 1) return 0;
	}
	return 1;
}
int check_out(int x) {
	for (int i = 0; i < n; ++i) {
		if(out[x][i] == 0) return 0;
	}
	return 1;
}
int check(int x, int y) {
	for (int i = 0; i < n; ++i) {
		if (in[y][i] == 2) continue;
		if (out[x][i] != in[y][i]) return 0;
	}
	return 1;
}
int main () {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	while (cin >> n >> m) {
		memset(g, 0, sizeof(g));
		memset(used, 0, sizeof(used));
		for (int i = 1; i <= m; ++i) {
			cin >> val[i];
			for (int j = 0; j < n; ++j) cin >> in[i][j];
			for (int j = 0; j < n; ++j) cin >> out[i][j];
		}
		int s = 0, e = m + 1;
		for (int i = 1; i <= m; ++i) {
			if (check_in(i)) {
				g[s][i] = val[i];
				used[i] = 1;
			}
			if (check_out(i)) {
				g[i][e] = val[i];
				continue;
			}
			for (int j = 1; j <= m; ++j) {
				if (i == j || used[j]) continue;
				if (check(i, j)) g[i][j] = val[i];
			}
		}
		memcpy(backup, g, sizeof(g));
		int ans = ek(s, e);
		vector<int> all;
		for (int i = 1; i <= m; ++i) {
			for (int j = 1; j <= m; ++j) {
				if (backup[i][j] > g[i][j]) {
					all.push_back(i);
					all.push_back(j);
					all.push_back(backup[i][j] - g[i][j]);
				}
			}
		}
		cout << ans << " " << all.size() / 3 << endl;
		for (int i = 0; i < (int)all.size(); i += 3) {
			cout<< all[i] << " " << all[i+1] << " " << all[i+2] << endl;
		}
	}
	return 0;	
}
```

<h3 id="B">Dining(POJ-3281)</h3>
#### 题意
每头牛都有各自喜欢的食物和饮料，而每种食物或饮料只能分配给一头牛。最多能有多少头牛可以同时得到喜欢的食物和饮料？
#### 思路
最大流
将牛拆成点，限制牛的流量。保证增光路上对应得是牛喜欢的食物和水
```cpp
#include <iostream>
#include <queue>
#include <cstring>
const int maxn = 4e2 + 5;
const int inf = 0x3f3f3f3f;
using namespace std;
struct ac{
	int v, c, nex;
}edge[maxn << 4];
int head[maxn], curedge[maxn], cnt, s, e;
int dis[maxn];
void init() {
	memset(head, -1, sizeof(head));
	cnt = 0;
}
void addedge(int u, int v, int c) {
	edge[cnt] = {v, c, head[u]};
	head[u] = cnt++;
	edge[cnt] = {u, 0, head[v]};
	head[v] = cnt++;
}
int bfs() {
	memset(dis, 0, sizeof(dis));
	dis[s] = 1;
	queue<int> que;
	que.push(s);
	while (!que.empty()) {
		int u = que.front();
		que.pop();
		for (int i = head[u]; i != -1; i = edge[i].nex) {
			int v = edge[i].v;
			int c = edge[i].c;
			if (dis[v] || c == 0) continue;
			dis[v] = dis[u] + 1;
			que.push(v);
		}
	}
	return dis[e] > 0;
}
int dfs(int u, int flow) {
	if (u == e || flow == 0) return flow;
	for (int &i = curedge[u]; i != -1; i = edge[i].nex) {
		int v = edge[i].v;
		int c = edge[i].c;
		if (dis[v] != dis[u] + 1) continue;
		int tmp = dfs(v, min(flow, c));
		if (tmp > 0) {
			edge[i].c -= tmp;
			edge[i^1].c += tmp;
			return tmp;
		}
	}
	dis[u] = -1;
	return 0;
}
int Dinic() {
	int ans = 0, tmp;
	while (bfs()) {
		for (int i = 0; i <= e; ++i) curedge[i] = head[i];
		while ((tmp = dfs(s, inf)) > 0) ans += tmp;
	}
	return ans;
}
int main () {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int n, f, d;
    while (cin >> n >> f >> d) {
    	init();
	    s = 0, e = n*2 + f + d + 1;
	    for (int i = 1; i <= n; ++i) {
	    	int a, b, t;
	    	cin >> a >> b;
	    	for (int j = 1; j <= a; ++j) {
	    		cin >> t;
	    		addedge(t, f+i, 1);
	    	}
	    	for (int j = 1; j <= b; ++j) {
	    		cin >> t;
	    		addedge(f+n+i, n*2+f+t, 1);
	    	}
	    }
	    for (int j = 1; j <= f; ++j) addedge(s, j, 1);
	    for (int j = 1; j <= d; ++j) addedge(n*2+f+j, e, 1);
	    for (int j = 1; j <= n; ++j) addedge(f+j, f+n+j, 1);
	    cout << Dinic() << endl;
    }
    return 0;
}
```

<h3 id="C">C - A Plug for UNIX (POJ-1087)</h3>
#### 题意
一共有N个插座，M个设备，K个转换器，转换器可以无限提供，问最少有多少个设备不能连接电源
#### 思路
最大流
建图：
- 源点到设备流量1
- 插座到汇点流量1
- 转换器之间流量inf
```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
#include <map>
#include <cstring>
const int maxn = 4e2 + 5;
const int inf = 0x3f3f3f3f;
using namespace std;
struct ac{
	int v, c, nex;
}edge[maxn << 7];
int head[maxn], curedge[maxn], cnt, s, e;
int dis[maxn];
int a[maxn][maxn];
void init() {
	memset(head, -1, sizeof(head));
	memset(a, 0, sizeof(a));
	cnt = 0;
}
void addedge(int u, int v, int c) {
	edge[cnt] = {v, c, head[u]};
	head[u] = cnt++;
	edge[cnt] = {u, 0, head[v]};
	head[v] = cnt++;
}
int bfs() {
	memset(dis, 0, sizeof(dis));
	dis[s] = 1;
	queue<int> que;
	que.push(s);
	while (!que.empty()) {
		int u = que.front();
		que.pop();
		for (int i = head[u]; i != -1; i = edge[i].nex) {
			int v = edge[i].v;
			int c = edge[i].c;
			if (dis[v] || c == 0) continue;
			dis[v] = dis[u] + 1;
			que.push(v);
		}
	}
	return dis[e] > 0;
}
int dfs(int u, int flow) {
	if (u == e || flow == 0) return flow;
	for (int &i = curedge[u]; i != -1; i = edge[i].nex) {
		int v = edge[i].v;
		int c = edge[i].c;
		if (dis[v] != dis[u] + 1) continue;
		int tmp = dfs(v, min(flow, c));
		if (tmp > 0) {
			edge[i].c -= tmp;
			edge[i^1].c += tmp;
			return tmp;
		}
	}
	dis[u] = -1;
	return 0;
}
int Dinic() {
	int ans = 0, tmp;
	while (bfs()) {
		for (int i = 0; i <= e; ++i) curedge[i] = head[i];
		while ((tmp = dfs(s, inf)) > 0) ans += tmp;
	}
	return ans;
}
int main () {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int n, m, q;
    while (cin >> n) {
    	init();
    	map<string, int> mp;
    	int num = 0;
    	vector<string> have(maxn), device(maxn);
    	for (int i = 0; i < n; ++i) {
    		cin >> have[i];
    		if (mp[have[i]] == 0) mp[have[i]] = ++num;
    	}
    	cin >> m;
    	for (int j = 0; j < m; ++j) {
    		cin >> device[j] >> device[j];
    		if (mp[device[j]] == 0) mp[device[j]] = ++num;
    	}
    	cin >> q;
    	for (int i = 0; i < q; ++i) {
    		string l, r;
    		cin >> l >> r;
    		if (mp[l] == 0) mp[l] = ++num;
    		if (mp[r] == 0) mp[r] = ++num;
    		addedge(mp[l], mp[r], inf);
    	}
    	s = 0, e = num + 1;
    	for (int i = 0; i < m; ++i) addedge(s, mp[device[i]], 1);
    	for (int i = 0; i < n; ++i) addedge(mp[have[i]], e, 1);
    	cout << m - Dinic() << endl;
    }
    return 0;
}
```

<h3 id="D">ACM Computer Factory(POJ-3436)</h3>
#### 题意

#### 思路

```cpp

```

<h3 id="A">D - Going Home(POJ-2195)</h3>
#### 题意
n个人要进到房子里面，每个人的花费是他移动的距离。求n个人进房子的最小花费
#### 思路
费用流

```cpp
#include <iostream>
#include <queue>
#include <cmath>
#include <cstring>
const int maxn = 1e4 + 5;
const int inf = 0x3f3f3f3f;
using namespace std;
int path[maxn], dis[maxn], head[maxn], vis[maxn];
int cnt, s, e;
void init() {
	memset(head, -1, sizeof(head));
	cnt = 0;
}
struct ac{
	int v, c, cost, nex;
}edge[maxn << 11];
void addedge(int u, int v, int c, int cost) {
	edge[cnt] = {v, c, cost, head[u]};
	head[u] = cnt++;
	edge[cnt] = {u, 0, -cost, head[v]};
	head[v] = cnt++;
}
int spfa(int s, int e) {
	memset(vis, 0, sizeof(vis));
	memset(dis, inf, sizeof(dis));
	memset(path, -1, sizeof(path));
	queue<int> que;
	que.push(s);
	dis[s] = 0;
	vis[s] = 1;
	while (!que.empty()) {
		int u = que.front();
		que.pop();
		vis[u] = 0;
		for (int i = head[u]; i != -1; i = edge[i].nex) {
			int v = edge[i].v;
			int c = edge[i].c;
			int cost = edge[i].cost;
			if (dis[v] > dis[u] + cost && c > 0) {
				dis[v] = dis[u] + cost;
				path[v] = i;
				if (vis[v]) continue;
				vis[v] = 1;
				que.push(v);
			}
		}
	}
	return dis[e] != inf;
}
int MincostMaxflow(int s, int e, int &cost) {
	int maxflow = 0;
	while (spfa(s, e)) {
		int flow = inf;
		for (int i = path[e]; i != -1; i = path[edge[i^1].v]) {
			flow = min(flow, edge[i].c);
		}
		for (int i = path[e]; i != -1; i = path[edge[i^1].v]) {
			edge[i].c -= flow;
			edge[i^1].c += flow;
			cost += flow * edge[i].cost;
		}
		maxflow += flow;
	}
	return maxflow;
}
int main () {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int n, m; char c;
	while (cin >> n >> m, n) {
		init();
		vector<pair<int,int> > H, M;
		for(int i = 0; i < n; ++i) {
			for (int j = 0; j < m; ++j) {
				cin >> c;
				if (c == 'm') M.push_back(make_pair(i, j));
				if (c == 'H') H.push_back(make_pair(i, j)); 
			}
		}
		int cntH = H.size();
		int cntM = M.size();
		s = 0, e = cntH + cntM + 1;
		for (int i = 0; i < cntM; ++i) {
			addedge(s, i+1, 1, 0);
		}
		for (int i = 0; i < cntH; ++i) {
			addedge(cntM+i+1, e, 1, 0);
		}
		for (int i = 0; i < cntH; ++i) {
			for (int j = 0; j < cntM; ++j) {
				int cost = fabs(H[i].first - M[j].first) + fabs(H[i].second - M[j].second);
				addedge(j+1, cntM+i+1, 1, cost);
			}
		}
		int cost = 0;
		MincostMaxflow(s, e, cost);
		cout << cost << endl;
	}
	return 0;	
}
```

<h3 id="E">E - Minimum Cost(POJ-2516)</h3>
#### 题意
N个商店每个商店需要K个货物，需求量各不相同，M个供应商每个供应商都提供K个货物，供应量各不相同，货物不同的供应商提供的价格不同，求最小的花费满足N个商店的需求
#### 思路
费用流
每种货物互相不影响，每种货物可以单独考虑，简化建图
建图：
- 源点到供应商 流量为存货量，费用为0
- 供应商到商店 流量为inf，费用为对应的单价
- 商店到汇点 流量为需求量，费用为0

```cpp
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <queue>
const int maxn = 1e2 + 5;
const int inf = 0x3f3f3f3f;
using namespace std;
struct ac{
	int v, c, cost, nex;
}edge[maxn << 5];
int dis[maxn], vis[maxn];
int head[maxn], cnt, path[maxn];
void addedge(int u, int v, int c, int cost) {
	edge[cnt] = {v, c, cost, head[u]};
	head[u] = cnt++;
	edge[cnt] = {u, 0, -cost, head[v]};
	head[v] = cnt++;	
}
void init() {
	memset(head, -1, sizeof(head));
	cnt = 0;
}
int spfa(int s, int e) {
	memset(vis, 0, sizeof(vis));
	memset(dis, inf, sizeof(dis));
	memset(path, -1, sizeof(path));
	dis[s] = 0;
	vis[s] = 1;
	queue<int> que;
	que.push(s);
	while (!que.empty()) {
		int u = que.front();
		que.pop();
		vis[u] = 0;
		for (int i = head[u]; i != -1; i = edge[i].nex) {
			int v = edge[i].v;
			int c = edge[i].c;
			int cost = edge[i].cost;
			if (c == 0 || dis[v] <= dis[u] + cost) continue;
			path[v] = i;
			dis[v] = dis[u] + cost;
			if (vis[v]) continue;
			vis[v] = 1;
			que.push(v);
		}
	}
	return dis[e] != inf;
}
int MCMF(int s, int e, int &cost) {
	int maxflow = 0;
	while (spfa(s, e)) {
		int flow = inf;
		for (int i = path[e]; i != -1; i = path[edge[i^1].v]) {
			flow = min(flow, edge[i].c);
		}
		for (int i = path[e]; i != -1; i = path[edge[i^1].v]) {
			edge[i].c -= flow;
			edge[i^1].c += flow;
			cost += flow * edge[i].cost;
		}
		maxflow += flow;
	}
	return maxflow;
}
int supply[55][55];
int need[55][55];
int price[55][55][55];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int n, m, k;
	while (cin >> n >> m >> k, n) {
		for (int i = 1; i <= n; ++i) {
			for (int j = 1; j <= k; ++j) {
				cin >> need[i][j]; // 商店i需要货物j
			}
		}
		for (int i = 1; i <= m; ++i) {
			for (int j = 1; j <= k; ++j) {
				cin >> supply[i][j]; // 供应商i提供货物j
			}
		}
		for (int q = 1; q <= k; ++q) {
			for (int i = 1; i <= n; ++i) {
				for (int j = 1; j <= m; ++j) {
					cin >> price[q][j][i]; // 货物q从j到i的价格
				}
			}
		}
		// 分开对每个货物求费用流
		int s = 0, e = m + n + 1;
		int ans = 0;
		for (int q = 1; q <= k; ++q) {
			int sum = 0;
			for (int i = 1; i <= n; ++i) {
				sum += need[i][q];
			}
			init();
			for (int i = 1; i <= m; ++i) addedge(s, i, supply[i][q], 0);
			for (int i = 1; i <= n; ++i) addedge(m+i, e, need[i][q], 0);
			for (int i = 1; i <= m; ++i) {
				for (int j = 1; j <= n; ++j) {
					addedge(i, m+j, inf, price[q][i][j]);
				}
			}
			int maxflow = MCMF(s, e, ans);
			if (maxflow != sum) {
				ans = -1;
				break;
			}
		}
		cout << ans << endl;
	}
	return 0;
}
```

<h3 id="A">F - Power Network(POJ - 1459)</h3>
#### 题意
np个发电站供电，mc个用户消耗，m条线路，求最大的消耗量
#### 思路
最大流
```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
#include <cstring>
const int maxn = 2e2 + 5;
const int inf = 0x3f3f3f3f;
using namespace std;
struct ac{
	int v, c, nex;
}edge[maxn << 8];
int head[maxn], cnt;
int dis[maxn], s, e;
int curedge[maxn];
void addedge(int u, int v, int c) {
	edge[cnt] = {v, c, head[u]};
	head[u] = cnt++;
	edge[cnt] = {u, 0, head[v]};
	head[v] = cnt++;
}
int bfs() {
	memset(dis, 0, sizeof(dis));
	dis[s] = 1;
	queue<int> que;
	que.push(s);
	while (!que.empty()) {
		int u = que.front();
		que.pop();
		for (int i = head[u]; i != -1; i = edge[i].nex) {
			int v = edge[i].v;
			int c = edge[i].c;
			if (c == 0 || dis[v]) continue;
			dis[v] = dis[u] + 1;
			que.push(v);
		}
	}
	return dis[e];
}
int dfs(int u, int flow) {
	if (u == e || flow == 0) return flow;
	for (int &i = curedge[u]; i != -1; i = edge[i].nex) {
		int v = edge[i].v;
		int c = edge[i].c;
		if (c == 0 || dis[v] != dis[u] + 1) continue;
		int tmp = dfs(v, min(flow, c));
		if (tmp > 0) {
			edge[i].c -= tmp;
			edge[i^1].c += tmp;
			return tmp;
		}
	}
	dis[u] = -1;
	return 0;
}
int Dinic() {
	int ans = 0, d;
	while (bfs()) {
		for (int i = 0; i <= e; ++i) curedge[i] = head[i];
		while ((d = dfs(s, inf)) > 0) ans += d;
	}
	return ans;
}
int main () {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int n, np, nc, m;
	while (scanf("%d %d %d %d", &n, &np, &nc, &m) != EOF) {
		s = n, e = n + 1;
		memset(head, -1, sizeof(head));
		cnt = 0;
		int u, v, c;
		for (int i = 0; i < m; ++i) {
			scanf(" (%d,%d)%d", &u, &v, &c);
			addedge(u, v, c);
		}
		for (int i = 0; i < np; ++i) {
			scanf(" (%d)%d", &v, &c);
			addedge(s, v, c);
		}
		for (int i = 0; i < nc; ++i) {
			scanf(" (%d)%d", &v, &c);
			addedge(v, e, c);
		}
		printf("%d\n", Dinic());
	}
	return 0;	
}
```

<h3 id="A">ACM Computer Factory(POJ-3436)</h3>
#### 题意

#### 思路

```cpp

```

<h3 id="A">ACM Computer Factory(POJ-3436)</h3>
#### 题意

#### 思路

```cpp

```
